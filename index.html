<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>苏州市智慧交通系统 (历史回放版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdel                    label.setStyle({
                        backgroundColor: "#1E88E5",
                        color: "#FFFFFF",
                        border: "none",
                        borderRadius: "12px",
                        padding: "6px 10px",
                        fontSize: "12px",
                        lineHeight: "18px",
                        boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
                        whiteSpace: "normal",
                        wordWrap: "break-word",
                        maxWidth: "200px"
                    });/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&amp;ak=cQgiplWjsTZs6D38GtVxwwZGFClmPnSx"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/zh.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: { primary: '#1E88E5', danger: '#D32F2F', dark: '#263238' }
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .glass { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.1); }
            #video-container {
                position: fixed; z-index: 50; background: #000;
                box-shadow: 0 20px 50px rgba(0,0,0,0.5); border-radius: 8px; overflow: hidden; resize: none;
                min-width: 240px; min-height: 160px;
            }
            #video-container::-webkit-resizer { background: transparent; }
            .resize-handle {
                position: absolute; bottom: 0; right: 0; width: 20px; height: 20px;
                background: linear-gradient(135deg, transparent 50%, #D32F2F 50%);
                cursor: se-resize; pointer-events: auto; z-index: 60;
            }
            .resize-handle-right {
                position: absolute; top: 0; right: 0; width: 12px; height: 100%;
                cursor: e-resize; z-index: 70; background: transparent;
            }
            .resize-handle-left {
                position: absolute; top: 0; left: 0; width: 12px; height: 100%;
                cursor: w-resize; z-index: 70; background: transparent;
            }
            .resize-handle-bottom {
                position: absolute; left: 0; bottom: 0; width: 100%; height: 12px;
                cursor: s-resize; z-index: 70; background: transparent;
            }
            .resize-handle-top {
                position: absolute; left: 0; top: 0; width: 100%; height: 12px;
                cursor: n-resize; z-index: 70; background: transparent;
            }
            .resize-handle-right::after,
            .resize-handle-bottom::after {
                content: "";
                position: absolute;
                inset: 0;
                background: rgba(255,255,255,0.06);
            }
            .resize-handle-left::after,
            .resize-handle-top::after {
                content: "";
                position: absolute;
                inset: 0;
                background: rgba(255,255,255,0.06);
            }
            .map-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
            .overlay { position: absolute; z-index: 20; }
        }
    </style>
</head>
<body class="font-sans text-dark overflow-hidden h-screen w-screen bg-gray-200">

<div id="map" class="map-container"></div>

<div class="overlay top-0 w-full py-3 bg-white/90 shadow flex justify-center pointer-events-none">
    <h1 class="text-2xl font-bold flex items-center pointer-events-auto">
        <i class="fa fa-road text-primary mr-3"></i>
        苏州市智慧交通系统 <span class="text-xs bg-primary text-white px-2 py-0.5 rounded ml-2">Live Drone</span>
    </h1>
</div>

<div class="overlay left-4 top-20 glass w-80 p-5 rounded-xl shadow-xl hover:scale-[1.01] transition">
    <h2 class="text-lg font-bold mb-3 border-b pb-2 text-primary">
        <i class="fa fa-globe"></i> 道路精准标红
    </h2>
    <div class="space-y-3">
        <input type="text" id="road-name" placeholder="输入路名 (如: 干将路)"
               class="w-full px-3 py-2 rounded border border-gray-300 focus:ring-2 focus:ring-primary outline-none">
        <button id="search-road-btn" class="w-full bg-primary hover:bg-blue-600 text-white font-bold py-2 rounded shadow transition flex justify-center items-center">
            <span>获取全路网形状</span>
        </button>
        <div id="road-status" class="text-xs text-gray-500 bg-gray-50 p-2 rounded min-h-[40px]">
            <i class="fa fa-info-circle"></i> VPN状态检测中...
        </div>
    </div>
</div>

<div class="overlay right-4 top-20 bottom-4 w-72 flex flex-col gap-3 pointer-events-none">

    <div class="glass p-3 rounded-xl shadow-lg pointer-events-auto flex flex-col">
        <h3 class="font-bold text-sm mb-2 text-gray-700">无人机实时状态</h3>
        <div id="drone-info" class="p-2 bg-gray-50 rounded mb-2 text-xs font-mono">
            等待数据连接...
        </div>
    </div>

    <div class="glass p-3 rounded-xl shadow-lg pointer-events-auto flex flex-col">
        <h3 class="font-bold text-sm mb-2 text-gray-700"><i class="fa fa-history text-primary"></i> 历史轨迹回放</h3>
        <div class="space-y-2 text-xs">
            <div>
                <label class="block text-gray-500 mb-1">开始时间</label>
                <input type="text" id="start-time" class="w-full border rounded p-1 bg-white cursor-pointer" placeholder="选择开始时间...">
            </div>
            <div>
                <label class="block text-gray-500 mb-1">结束时间</label>
                <input type="text" id="end-time" class="w-full border rounded p-1 bg-white cursor-pointer" placeholder="选择结束时间...">
            </div>
            <div class="flex gap-2 pt-2">
                <button onclick="queryHistory()" class="flex-1 bg-blue-600 text-white py-1.5 rounded hover:bg-blue-700 transition">
                    查询路径
                </button>
                <button onclick="clearHistory()" class="flex-1 bg-gray-400 text-white py-1.5 rounded hover:bg-gray-500 transition">
                    清除
                </button>
            </div>
            <div id="history-status" class="text-gray-500 pt-1 italic"></div>
        </div>
    </div>

    <div class="glass p-3 rounded-xl shadow-lg pointer-events-auto h-40 flex flex-col">
        <h3 class="font-bold text-sm mb-2 text-gray-700">实时流量</h3>
        <div class="flex-1 relative"><canvas id="dateChart"></canvas></div>
    </div>
</div>

<div id="video-container" style="left: 20px; bottom: 20px; width: 320px; height: 220px;">
    <div id="video-header" class="bg-gray-900 text-white px-3 py-2 cursor-move flex justify-between items-center select-none">
        <span class="font-bold text-xs"><i class="fa fa-video-camera text-red-500 mr-2"></i>实时监控</span>
        <i class="fa fa-arrows text-gray-500"></i>
    </div>
    <div class="relative w-full h-full bg-black pb-8">
        <img id="video1" src="http://localhost:8000/video_feed" class="w-full h-full object-cover pointer-events-none" alt="NO SIGNAL"
             onerror="this.style.display='none'; this.parentElement.innerHTML+='<div class=\'absolute inset-0 flex items-center justify-center text-white text-xs\'>信号中断</div>'"/>
    </div>
    <div class="resize-handle"></div>
    <div class="resize-handle-right"></div>
    <div class="resize-handle-left"></div>
    <div class="resize-handle-bottom"></div>
    <div class="resize-handle-top"></div>
</div>

<script>
    let map;
    let currentOverlays = []; // 路网红线
    let historyOverlay = null; // 历史蓝线
    let historyPointOverlays = []; // 历史点及标签
    let dateChart = null;

    // 实时追踪变量
    let droneMarker = null;
    let dronePathLine = null;
    let dronePathPoints = [];
    let detectionMarkers = [];
    let lastDetectionRecord = 0;

    window.onload = function() {
        initMap();
        initCharts();
        initDraggableVideo();
        initResizableVideo();
        initEvents();
        startDroneTracking();
    startDetectionRecording();

        // --- 初始化 Flatpickr (24小时制) ---
        const now = new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

        const fpConfig = {
            enableTime: true,
            time_24hr: true,        // 强制 24小时制
            dateFormat: "Y-m-dTH:i",// 传给后台的格式 (2023-10-27T14:00)
            altInput: true,
            altFormat: "Y-m-d H:i", // 用户看到的格式
            locale: "zh"
        };

        flatpickr("#start-time", { ...fpConfig, defaultDate: oneHourAgo });
        flatpickr("#end-time", { ...fpConfig, defaultDate: now });
    };

    function initMap() {
        map = new BMap.Map("map", {enableMapClick: false});
        // 默认中心
        const center = new BMap.Point(120.619585, 31.299379);
        map.centerAndZoom(center, 13);
        map.enableScrollWheelZoom(true);
        map.setMapStyleV2({styleId: '3d96e57d1959828591f8936936319808'});
    }

    // ==========================================
    //  历史轨迹查询 (关键逻辑)
    // ==========================================
    async function queryHistory() {
        const start = document.getElementById('start-time').value;
        const end = document.getElementById('end-time').value;
        const statusDiv = document.getElementById('history-status');

        if(!start || !end) {
            statusDiv.innerHTML = "<span class='text-red-500'>请选择完整时间</span>";
            return;
        }

        statusDiv.innerHTML = "<i class='fa fa-spinner fa-spin'></i> 查询中...";
        clearHistory(); // 清除上一条线
        clearHistoryPoints(); // 清除历史点

        try {
            const url = `http://localhost:8000/api/history?start_time=${start}&end_time=${end}&_t=${Date.now()}`;
            const res = await fetch(url);
            const json = await res.json();

            if(json.status === 'success') {
                let points = json.data;

                // --- 前端二次过滤：剔除所有 (0,0) 的点，防止拉出直线 ---
                points = points.filter(p => Math.abs(p.lat) > 0.1 && Math.abs(p.lon) > 0.1);

                if(points.length === 0) {
                    statusDiv.innerHTML = "该时段无有效数据";
                    return;
                }

                statusDiv.innerHTML = `加载 ${points.length} 个点`;

                // 转换坐标
                const bdPoints = points.map(p => wgs84ToBd09(p.lon, p.lat));

                // 绘制蓝色粗线
                historyOverlay = new BMap.Polyline(bdPoints, {
                    strokeColor: "#0000FF", // 蓝色
                    strokeWeight: 5,
                    strokeOpacity: 0.6
                });
                map.addOverlay(historyOverlay);

                // 绘制历史点并添加悬浮提示
                points.forEach((p, idx) => {
                    const bdPoint = bdPoints[idx];
                    const circle = new BMap.Circle(bdPoint, 6, {
                        strokeColor: "#1E88E5",
                        strokeWeight: 1,
                        strokeOpacity: 0.6,
                        fillColor: "#1E88E5",
                        fillOpacity: 0.9
                    });

                    const latVal = parseFloat(p.lat);
                    const lonVal = parseFloat(p.lon);
                    const pCount = p.person_count || 0;
                    const cCount = p.car_count || 0;

                    const content = `<div style="text-align:left; color: white;"><div><b>坐标:</b> ${latVal.toFixed(6)}, ${lonVal.toFixed(6)}</div><div><b>时间:</b> ${p.time}</div><div><b>统计:</b> 行人${pCount} / 车辆${cCount}</div></div>`;

                    const label = new BMap.Label(content, {
                        position: bdPoint,
                        offset: new BMap.Size(12, -25)
                    });

                    label.setStyle({
                        backgroundColor: "#1E88E5",
                        color: "#FFFFFF",
                        border: "none",
                        borderRadius: "12px",
                        padding: "4px 8px",
                        fontSize: "12px",
                        lineHeight: "16px",
                        boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
                        whiteSpace: "nowrap"  // 防止换行符被忽略，但 br 标签应该生效
                    });

                    map.addOverlay(circle);
                    map.addOverlay(label);
                    label.hide();

                    let hideTimer = null;
                    const showLabel = () => {
                        if (hideTimer) clearTimeout(hideTimer);
                        label.show();
                    };
                    const hideLabel = () => {
                        hideTimer = setTimeout(() => label.hide(), 80);
                    };

                    circle.addEventListener('mouseover', showLabel);
                    circle.addEventListener('mouseout', hideLabel);
                    label.addEventListener('mouseover', showLabel);
                    label.addEventListener('mouseout', hideLabel);

                    historyPointOverlays.push({ circle, label });
                });

                // 自动缩放到轨迹范围
                map.setViewport(bdPoints);

            } else {
                statusDiv.innerHTML = "查询出错";
            }
        } catch(e) {
            console.error(e);
            statusDiv.innerHTML = "网络错误";
        }
    }

    function clearHistory() {
        if(historyOverlay) {
            map.removeOverlay(historyOverlay);
            historyOverlay = null;
        }
        clearHistoryPoints();
        document.getElementById('history-status').innerHTML = "";
    }

    function clearHistoryPoints() {
        historyPointOverlays.forEach(pair => {
            pair.label.hide();
            map.removeOverlay(pair.circle);
            map.removeOverlay(pair.label);
        });
        historyPointOverlays = [];
    }

    // ==========================================
    //  实时追踪 (每1秒更新)
    // ==========================================
    function startDroneTracking() {
        setInterval(async () => {
            try {
                const response = await fetch(`http://localhost:8000/api/drone_status?_t=${Date.now()}`);
                if (!response.ok) return;
                const data = await response.json();

                // 忽略无效坐标
                if (Math.abs(data.lat) < 0.1 && Math.abs(data.lon) < 0.1) return;

                document.getElementById('drone-info').innerHTML = `
                    <div class="flex justify-between">
                        <span>LAT: ${data.lat.toFixed(6)}</span>
                        <span>LON: ${data.lon.toFixed(6)}</span>
                    </div>
                    <div class="mt-1 text-green-600 font-bold">状态: ${data.status}</div>
                `;

                const bdPoint = wgs84ToBd09(data.lon, data.lat);

                // 更新或创建图标
                if (!droneMarker) {
                    const myIcon = new BMap.Icon("https://cdn-icons-png.flaticon.com/512/3069/3069186.png", new BMap.Size(32, 32));
                    droneMarker = new BMap.Marker(bdPoint, {icon: myIcon});
                    map.addOverlay(droneMarker);
                } else {
                    droneMarker.setPosition(bdPoint);
                }

                // 更新红色轨迹
                dronePathPoints.push(bdPoint);
                if (!dronePathLine) {
                    dronePathLine = new BMap.Polyline(dronePathPoints, {
                        strokeColor: "red",
                        strokeWeight: 3,
                        strokeOpacity: 0.8
                    });
                    map.addOverlay(dronePathLine);
                } else {
                    dronePathLine.setPath(dronePathPoints);
                }
            } catch (error) {}
        }, 1000);
    }

    // ==========================================
    //  检测统计记录 (在无人机位置打点)
    // ==========================================
    function startDetectionRecording() {
        setInterval(async () => {
            try {
                const res = await fetch(`http://localhost:8000/api/detection_counts?_t=${Date.now()}`);
                if (!res.ok) return;
                const counts = await res.json();

                // 取当前无人机位置
                if (!droneMarker) return;
                const pos = droneMarker.getPosition();
                if (!pos) return;

                // 没有检测到就不记录
                if (!counts || counts.total <= 0) return;

                const now = Date.now();
                if (now - lastDetectionRecord < 3000) return;
                lastDetectionRecord = now;

                const labelText = `检测统计<br>坐标: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}<br>时间: ${formatTimestamp(counts.timestamp)}<br>行人: ${counts.person} 车辆: ${counts.car}`;
                const marker = new BMap.Marker(pos);
                const label = new BMap.Label(labelText, {
                    position: pos,
                    offset: new BMap.Size(12, -12)
                });
                label.setStyle({
                    backgroundColor: "rgba(30,136,229,0.95)",
                    color: "#FFFFFF",
                    border: "none",
                    borderRadius: "10px",
                    padding: "4px 8px",
                    fontSize: "12px",
                    lineHeight: "16px"
                });
                label.hide();

                marker.addEventListener('mouseover', () => label.show());
                marker.addEventListener('mouseout', () => label.hide());

                map.addOverlay(marker);
                map.addOverlay(label);

                detectionMarkers.push({ marker, label });

                // 控制点数量，避免过多
                if (detectionMarkers.length > 50) {
                    const old = detectionMarkers.shift();
                    map.removeOverlay(old.marker);
                    map.removeOverlay(old.label);
                }
            } catch (e) {}
        }, 1000);
    }

    // ==========================================
    //  坐标转换 & Overpass (保持工具函数不变)
    // ==========================================
    const PI = 3.1415926535897932384626;
    const x_pi = 3.14159265358979324 * 3000.0 / 180.0;
    const a = 6378245.0; const ee = 0.00669342162296594323;

    function wgs84ToBd09(lng, lat) { const gcj = wgs84ToGcj02(lng, lat); return gcj02ToBd09(gcj[0], gcj[1]); }
    function wgs84ToGcj02(lng, lat) {
        let dLat = transformLat(lng - 105.0, lat - 35.0); let dLng = transformLon(lng - 105.0, lat - 35.0);
        const radLat = lat / 180.0 * PI; let magic = Math.sin(radLat); magic = 1 - ee * magic * magic; const sqrtMagic = Math.sqrt(magic);
        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * PI); dLng = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * PI);
        return [lng + dLng, lat + dLat];
    }
    function gcj02ToBd09(lng, lat) {
        const z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_pi);
        const theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_pi);
        return new BMap.Point(z * Math.cos(theta) + 0.0065, z * Math.sin(theta) + 0.006);
    }
    function transformLat(x, y) {
        let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
        ret += (160.0 * Math.sin(y / 12.0 * PI) + 320.0 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0; return ret;
    }
    function transformLon(x, y) {
        let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
        ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0; return ret;
    }

    // Overpass Search
    async function searchRoad() {
        const input = document.getElementById('road-name'); const status = document.getElementById('road-status');
        const btn = document.getElementById('search-road-btn'); const name = input.value.trim();
        if (!name) return;
        clearOverlays(); status.innerHTML = '<span class="text-blue-600"><i class="fa fa-spinner fa-spin"></i> 连接 Overpass API...</span>';
        btn.disabled = true; btn.classList.add('opacity-50');
        const query = `[out:json][timeout:25];(way["name"~"${name}"](30.7,119.8,32.2,121.5);relation["name"~"${name}"](30.7,119.8,32.2,121.5););out geom;`;
        try {
            const response = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: 'data=' + encodeURIComponent(query) });
            if (!response.ok) throw new Error("API连接失败");
            const data = await response.json();
            if (!data.elements || data.elements.length === 0) { status.innerHTML = '<span class="text-red-500">未找到数据</span>'; btn.disabled = false; btn.classList.remove('opacity-50'); return; }
            status.innerHTML = `<span class="text-green-600">找到 ${data.elements.length} 个结果</span>`;
            processOverpassData(data.elements); btn.disabled = false; btn.classList.remove('opacity-50');
        } catch (error) { status.innerHTML = '<span class="text-red-500">连接超时/需VPN</span>'; fallbackToBaidu(name); btn.disabled = false; btn.classList.remove('opacity-50'); }
    }
    function processOverpassData(elements) {
        let allPoints = [];
        elements.forEach(el => {
            let path = [];
            if (el.type === 'way' && el.geometry) path = el.geometry.map(pt => wgs84ToBd09(pt.lon, pt.lat));
            else if (el.type === 'relation' && el.members) { el.members.forEach(m => { if (m.type === 'way' && m.geometry) { const sub = m.geometry.map(pt => wgs84ToBd09(pt.lon, pt.lat)); drawRedLine(sub); allPoints.push(...sub); } }); return; }
            if (path.length > 0) { drawRedLine(path); allPoints.push(...path); }
        });
        if (allPoints.length > 0) { const center = allPoints[Math.floor(allPoints.length / 2)]; map.setViewport(allPoints); const mk = new BMap.Marker(center); map.addOverlay(mk); currentOverlays.push(mk); }
    }
    function drawRedLine(points) { const line = new BMap.Polyline(points, {strokeColor: "#FF0000", strokeWeight: 6, strokeOpacity: 0.9}); map.addOverlay(line); currentOverlays.push(line); }
    function fallbackToBaidu(name) { const local = new BMap.LocalSearch(map, { onSearchComplete: (res) => { if (local.getStatus() === BMAP_STATUS_SUCCESS && res.getNumPois() > 0) { const pt = res.getPoi(0).point; map.centerAndZoom(pt, 15); const mk = new BMap.Marker(pt); map.addOverlay(mk); currentOverlays.push(mk); } } }); local.search(name); }
    function clearOverlays() { currentOverlays.forEach(o => map.removeOverlay(o)); currentOverlays = []; }

    // Video Drag
    function initDraggableVideo() {
        const c = document.getElementById("video-container"); const h = document.getElementById("video-header");
        let isD = false, sX, sY, sL, sT;
        h.addEventListener("mousedown", (e) => { isD = true; sX = e.clientX; sY = e.clientY; const st = window.getComputedStyle(c); sL = parseInt(st.left); sT = parseInt(st.top); });
        document.addEventListener("mousemove", (e) => { if (!isD) return; e.preventDefault(); c.style.left = `${sL + e.clientX - sX}px`; c.style.top = `${sT + e.clientY - sY}px`; });
        document.addEventListener("mouseup", () => isD = false);
    }
    function initResizableVideo() {
        const c = document.getElementById("video-container");
        const corner = c.querySelector(".resize-handle");
        const right = c.querySelector(".resize-handle-right");
        const left = c.querySelector(".resize-handle-left");
        const bottom = c.querySelector(".resize-handle-bottom");
        const top = c.querySelector(".resize-handle-top");
        if (!corner || !right || !bottom || !left || !top) return;

    // 将 bottom 定位转换为 top，便于上下拉伸
    const rectInit = c.getBoundingClientRect();
    c.style.left = `${rectInit.left}px`;
    c.style.top = `${rectInit.top}px`;
    c.style.bottom = "auto";

    let resizing = false;
        let mode = "corner";
    let startX = 0, startY = 0, startW = 0, startH = 0, startL = 0, startT = 0, ratio = 1;

        const startResize = (e, m) => {
            resizing = true;
            mode = m;
            startX = e.clientX;
            startY = e.clientY;
            const rect = c.getBoundingClientRect();
            startW = rect.width;
            startH = rect.height;
            startL = rect.left;
            startT = rect.top;
            ratio = startW / startH;
            e.preventDefault();
        };

        corner.addEventListener("mousedown", (e) => startResize(e, "corner"));
        right.addEventListener("mousedown", (e) => startResize(e, "right"));
    left.addEventListener("mousedown", (e) => startResize(e, "left"));
        bottom.addEventListener("mousedown", (e) => startResize(e, "bottom"));
    top.addEventListener("mousedown", (e) => startResize(e, "top"));

        document.addEventListener("mousemove", (e) => {
            if (!resizing) return;

            let newW = startW;
            let newH = startH;
            let newL = startL;
            let newT = startT;

            if (mode === "right") {
                newW = Math.max(240, startW + (e.clientX - startX));
                newH = Math.max(160, newW / ratio);
            } else if (mode === "left") {
                newW = Math.max(240, startW - (e.clientX - startX));
                newH = Math.max(160, newW / ratio);
                newL = startL + (startW - newW);
            } else if (mode === "bottom") {
                newH = Math.max(160, startH + (e.clientY - startY));
                newW = Math.max(240, newH * ratio);
            } else if (mode === "top") {
                newH = Math.max(160, startH - (e.clientY - startY));
                newW = Math.max(240, newH * ratio);
                newT = startT + (startH - newH);
            } else {
                const delta = Math.max(e.clientX - startX, e.clientY - startY);
                newW = Math.max(240, startW + delta);
                newH = Math.max(160, newW / ratio);
            }

            c.style.width = `${newW}px`;
            c.style.height = `${newH}px`;
            c.style.left = `${newL}px`;
            c.style.top = `${newT}px`;
        });

        document.addEventListener("mouseup", () => { resizing = false; });
    }
    function initCharts() { new Chart(document.getElementById('dateChart'), {type: 'line', data: {labels: ['8:00', '10:00', '12:00', '14:00'], datasets: [{label:'流量',data:[10,20,15,30],borderColor:'#1E88E5',fill:true}]}, options: {responsive:true,maintainAspectRatio:false}}); }
    function initEvents() { document.getElementById('search-road-btn').addEventListener('click', searchRoad); document.getElementById('road-name').addEventListener('keydown', (e) => { if(e.key==='Enter') searchRoad(); }); }



    function formatTimestamp(timeStr) {
        if (!timeStr) return "";
        return timeStr.replace('T', ' ').split('.')[0];
    }
</script>
</body>
</html>